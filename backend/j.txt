// ============================================
// BACKEND COMPLETE IMPLEMENTATION
// ============================================

// ============================================
// 1. SERVER - server.js
// ============================================
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config();

const app = express();

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/surveys', require('./routes/surveys'));
app.use('/api/admin', require('./routes/admin'));
app.use('/api/students', require('./routes/students'));

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'Server is running', timestamp: new Date() });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    success: false, 
    error: process.env.NODE_ENV === 'production' ? 'Internal server error' : err.message 
  });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

module.exports = app;

// ============================================
// 2. DATABASE CONFIG - config/database.js
// ============================================
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'mmesa_survey',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  enableKeepAlive: true,
  keepAliveInitialDelayMs: 0
});

// Test connection
pool.getConnection()
  .then(conn => {
    console.log('✓ Database connected successfully');
    conn.release();
  })
  .catch(err => {
    console.error('✗ Database connection failed:', err);
  });

module.exports = pool;

// ============================================
// 3. STUDENT MODEL - models/Student.js
// ============================================
const pool = require('../config/database');

class Student {
  static async create(email, indexNumber, year, phoneNumber) {
    try {
      const [result] = await pool.execute(
        'INSERT INTO students (email, index_number, year_of_study, phone_number) VALUES (?, ?, ?, ?)',
        [email, indexNumber, year, phoneNumber]
      );
      return result.insertId;
    } catch (error) {
      if (error.code === 'ER_DUP_ENTRY') {
        throw new Error('Email or index number already exists');
      }
      throw error;
    }
  }

  static async findByEmail(email) {
    const [rows] = await pool.execute(
      'SELECT * FROM students WHERE email = ?',
      [email]
    );
    return rows[0] || null;
  }

  static async findByIndexNumber(indexNumber) {
    const [rows] = await pool.execute(
      'SELECT * FROM students WHERE index_number = ?',
      [indexNumber]
    );
    return rows[0] || null;
  }

  static async findById(studentId) {
    const [rows] = await pool.execute(
      'SELECT * FROM students WHERE student_id = ?',
      [studentId]
    );
    return rows[0] || null;
  }

  static async getAll() {
    const [rows] = await pool.execute('SELECT * FROM students ORDER BY created_at DESC');
    return rows;
  }

  static async getByYear(year) {
    const [rows] = await pool.execute(
      'SELECT * FROM students WHERE year_of_study = ? ORDER BY created_at DESC',
      [year]
    );
    return rows;
  }

  static async update(studentId, data) {
    const { email, phoneNumber } = data;
    const [result] = await pool.execute(
      'UPDATE students SET email = ?, phone_number = ?, updated_at = NOW() WHERE student_id = ?',
      [email, phoneNumber, studentId]
    );
    return result.affectedRows > 0;
  }

  static async delete(studentId) {
    const [result] = await pool.execute(
      'DELETE FROM students WHERE student_id = ?',
      [studentId]
    );
    return result.affectedRows > 0;
  }

  static async getTotalCount() {
    const [rows] = await pool.execute('SELECT COUNT(*) as count FROM students');
    return rows[0].count;
  }
}

module.exports = Student;

// ============================================
// 4. SURVEY RESPONSE MODEL - models/SurveyResponse.js
// ============================================
const pool = require('../config/database');

class SurveyResponse {
  static async create(studentId, selectedOption, additionalCourse = null) {
    try {
      const [result] = await pool.execute(
        'INSERT INTO survey_responses (student_id, selected_option, additional_course_suggestion) VALUES (?, ?, ?)',
        [studentId, selectedOption, additionalCourse]
      );
      return result.insertId;
    } catch (error) {
      throw new Error('Failed to create survey response: ' + error.message);
    }
  }

  static async findById(responseId) {
    const [rows] = await pool.execute(
      'SELECT * FROM survey_responses WHERE response_id = ?',
      [responseId]
    );
    return rows[0] || null;
  }

  static async findByStudent(studentId) {
    const [rows] = await pool.execute(
      'SELECT * FROM survey_responses WHERE student_id = ? ORDER BY submitted_at DESC',
      [studentId]
    );
    return rows;
  }

  static async getAll() {
    const [rows] = await pool.execute(
      'SELECT * FROM survey_responses ORDER BY submitted_at DESC'
    );
    return rows;
  }

  static async getStatistics() {
    const [stats] = await pool.execute(`
      SELECT 
        COUNT(DISTINCT response_id) as total_responses,
        selected_option,
        COUNT(*) as option_count,
        COUNT(DISTINCT student_id) as unique_students
      FROM survey_responses
      GROUP BY selected_option
    `);
    return stats;
  }

  static async getTotalCount() {
    const [rows] = await pool.execute('SELECT COUNT(*) as count FROM survey_responses');
    return rows[0].count;
  }

  static async getResponsesByOption(option) {
    const [rows] = await pool.execute(
      'SELECT * FROM survey_responses WHERE selected_option = ? ORDER BY submitted_at DESC',
      [option]
    );
    return rows;
  }
}

module.exports = SurveyResponse;

// ============================================
// 5. MODULE MODEL - models/Module.js
// ============================================
const pool = require('../config/database');

class Module {
  static async findById(moduleId) {
    const [rows] = await pool.execute(
      'SELECT m.*, mc.category_name FROM modules m JOIN module_categories mc ON m.category_id = mc.category_id WHERE m.module_id = ?',
      [moduleId]
    );
    return rows[0] || null;
  }

  static async findByName(moduleName) {
    const [rows] = await pool.execute(
      'SELECT m.*, mc.category_name FROM modules m JOIN module_categories mc ON m.category_id = mc.category_id WHERE m.module_name = ?',
      [moduleName]
    );
    return rows[0] || null;
  }

  static async getAllByCategory(categoryId) {
    const [rows] = await pool.execute(
      'SELECT * FROM modules WHERE category_id = ? ORDER BY is_major_module DESC, module_name ASC',
      [categoryId]
    );
    return rows;
  }

  static async getAllMajor() {
    const [rows] = await pool.execute(
      'SELECT * FROM modules WHERE is_major_module = TRUE ORDER BY module_name ASC'
    );
    return rows;
  }

  static async getAllSub() {
    const [rows] = await pool.execute(
      'SELECT * FROM modules WHERE is_major_module = FALSE ORDER BY module_name ASC'
    );
    return rows;
  }

  static async getAll() {
    const [rows] = await pool.execute(
      'SELECT m.*, mc.category_name FROM modules m JOIN module_categories mc ON m.category_id = mc.category_id ORDER BY mc.category_name, m.is_major_module DESC, m.module_name'
    );
    return rows;
  }

  static async getPopularity(limit = 10) {
    const [rows] = await pool.execute(`
      SELECT 
        m.module_id,
        m.module_name,
        m.is_major_module,
        mc.category_name,
        COUNT(sms.selection_id) as selection_count
      FROM modules m
      LEFT JOIN student_module_selections sms ON m.module_id = sms.module_id
      LEFT JOIN module_categories mc ON m.category_id = mc.category_id
      GROUP BY m.module_id
      ORDER BY selection_count DESC
      LIMIT ?
    `, [limit]);
    return rows;
  }

  static async getSelectionCount(moduleId) {
    const [rows] = await pool.execute(
      'SELECT COUNT(*) as count FROM student_module_selections WHERE module_id = ?',
      [moduleId]
    );
    return rows[0].count;
  }
}

module.exports = Module;

// ============================================
// 6. SOFTWARE MODEL - models/Software.js
// ============================================
const pool = require('../config/database');

class Software {
  static async findById(softwareId) {
    const [rows] = await pool.execute(
      'SELECT * FROM software WHERE software_id = ?',
      [softwareId]
    );
    return rows[0] || null;
  }

  static async findByName(softwareName) {
    const [rows] = await pool.execute(
      'SELECT * FROM software WHERE software_name = ?',
      [softwareName]
    );
    return rows[0] || null;
  }

  static async getAll() {
    const [rows] = await pool.execute(
      'SELECT * FROM software ORDER BY software_name ASC'
    );
    return rows;
  }

  static async getPopularity(limit = 10) {
    const [rows] = await pool.execute(`
      SELECT 
        s.software_id,
        s.software_name,
        COUNT(sss.selection_id) as selection_count
      FROM software s
      LEFT JOIN student_software_selections sss ON s.software_id = sss.software_id
      GROUP BY s.software_id
      ORDER BY selection_count DESC
      LIMIT ?
    `, [limit]);
    return rows;
  }

  static async getSelectionCount(softwareId) {
    const [rows] = await pool.execute(
      'SELECT COUNT(*) as count FROM student_software_selections WHERE software_id = ?',
      [softwareId]
    );
    return rows[0].count;
  }

  static async getTotalCount() {
    const [rows] = await pool.execute('SELECT COUNT(*) as count FROM software');
    return rows[0].count;
  }
}

module.exports = Software;

// ============================================
// 7. SURVEY CONTROLLER - controllers/surveyController.js
// ============================================
const pool = require('../config/database');
const Student = require('../models/Student');
const SurveyResponse = require('../models/SurveyResponse');
const Module = require('../models/Module');
const Software = require('../models/Software');

exports.submitSurvey = async (req, res) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();

    const { email, indexNumber, year, phoneNumber, selectedOption, selectedModules, selectedSoftware, additionalCourse } = req.body;

    // Validate input
    if (!email || !indexNumber || !year || !phoneNumber || !selectedOption) {
      return res.status(400).json({ success: false, error: 'Missing required fields' });
    }

    if (!Array.isArray(selectedModules) || selectedModules.length === 0) {
      return res.status(400).json({ success: false, error: 'No modules selected' });
    }

    // Get or create student
    let [students] = await connection.execute(
      'SELECT student_id FROM students WHERE email = ? LIMIT 1',
      [email]
    );

    let studentId;
    if (students.length === 0) {
      const [result] = await connection.execute(
        'INSERT INTO students (email, index_number, year_of_study, phone_number) VALUES (?, ?, ?, ?)',
        [email, indexNumber, year, phoneNumber]
      );
      studentId = result.insertId;
    } else {
      studentId = students[0].student_id;
    }

    // Create survey response
    const [response] = await connection.execute(
      'INSERT INTO survey_responses (student_id, selected_option, additional_course_suggestion) VALUES (?, ?, ?)',
      [studentId, selectedOption, additionalCourse || null]
    );
    const responseId = response.insertId;

    // Insert module selections
    for (const moduleName of selectedModules) {
      const [module] = await connection.execute(
        'SELECT module_id FROM modules WHERE module_name = ? LIMIT 1',
        [moduleName]
      );
      if (module.length > 0) {
        await connection.execute(
          'INSERT INTO student_module_selections (response_id, module_id) VALUES (?, ?)',
          [responseId, module[0].module_id]
        );
      }
    }

    // Insert software selections
    if (Array.isArray(selectedSoftware)) {
      for (const softwareName of selectedSoftware) {
        const [software] = await connection.execute(
          'SELECT software_id FROM software WHERE software_name = ? LIMIT 1',
          [softwareName]
        );
        if (software.length > 0) {
          await connection.execute(
            'INSERT INTO student_software_selections (response_id, software_id) VALUES (?, ?)',
            [responseId, software[0].software_id]
          );
        }
      }
    }

    await connection.commit();
    res.status(201).json({ 
      success: true, 
      responseId, 
      studentId,
      message: 'Survey submitted successfully' 
    });
  } catch (error) {
    await connection.rollback();
    console.error('Survey submission error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  } finally {
    connection.release();
  }
};

exports.getAllResults = async (req, res) => {
  try {
    const [results] = await pool.execute(`
      SELECT 
        s.student_id,
        s.email,
        s.index_number,
        s.year_of_study,
        s.phone_number,
        sr.response_id,
        sr.selected_option,
        GROUP_CONCAT(m.module_name SEPARATOR ', ') as selected_modules,
        GROUP_CONCAT(sw.software_name SEPARATOR ', ') as selected_software,
        sr.additional_course_suggestion,
        sr.submitted_at
      FROM students s
      JOIN survey_responses sr ON s.student_id = sr.student_id
      LEFT JOIN student_module_selections sms ON sr.response_id = sms.response_id
      LEFT JOIN modules m ON sms.module_id = m.module_id
      LEFT JOIN student_software_selections sss ON sr.response_id = sss.response_id
      LEFT JOIN software sw ON sss.software_id = sw.software_id
      GROUP BY sr.response_id
      ORDER BY sr.submitted_at DESC
    `);
    
    res.json({ success: true, data: results, count: results.length });
  } catch (error) {
    console.error('Get results error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getStatistics = async (req, res) => {
  try {
    const [stats] = await pool.execute(`
      SELECT 
        COUNT(DISTINCT sr.response_id) as total_responses,
        COUNT(DISTINCT sr.student_id) as total_students,
        sr.selected_option,
        COUNT(*) as option_count
      FROM survey_responses sr
      GROUP BY sr.selected_option
    `);

    const [modulePopularity] = await pool.execute(`
      SELECT 
        m.module_id,
        m.module_name,
        m.is_major_module,
        mc.category_name,
        COUNT(sms.selection_id) as selection_count,
        ROUND(COUNT(sms.selection_id) * 100.0 / 
          (SELECT COUNT(DISTINCT response_id) FROM survey_responses), 1) as percentage
      FROM modules m
      LEFT JOIN student_module_selections sms ON m.module_id = sms.module_id
      LEFT JOIN module_categories mc ON m.category_id = mc.category_id
      GROUP BY m.module_id, m.module_name, m.is_major_module, mc.category_name
      ORDER BY selection_count DESC
      LIMIT 15
    `);

    const [softwarePopularity] = await pool.execute(`
      SELECT 
        s.software_id,
        s.software_name,
        COUNT(sss.selection_id) as selection_count,
        ROUND(COUNT(sss.selection_id) * 100.0 / 
          (SELECT COUNT(DISTINCT response_id) FROM survey_responses), 1) as percentage
      FROM software s
      LEFT JOIN student_software_selections sss ON s.software_id = sss.software_id
      GROUP BY s.software_id, s.software_name
      ORDER BY selection_count DESC
    `);

    const totalResponses = stats.reduce((sum, s) => sum + s.option_count, 0);

    res.json({ 
      success: true, 
      totalResponses,
      stats, 
      modulePopularity, 
      softwarePopularity 
    });
  } catch (error) {
    console.error('Statistics error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getDetailedReport = async (req, res) => {
  try {
    const { option } = req.query;
    
    let query = `
      SELECT 
        s.student_id,
        s.email,
        s.index_number,
        s.year_of_study,
        sr.response_id,
        sr.selected_option,
        GROUP_CONCAT(DISTINCT m.module_name SEPARATOR ', ') as modules,
        GROUP_CONCAT(DISTINCT sw.software_name SEPARATOR ', ') as software,
        sr.submitted_at
      FROM students s
      JOIN survey_responses sr ON s.student_id = sr.student_id
      LEFT JOIN student_module_selections sms ON sr.response_id = sms.response_id
      LEFT JOIN modules m ON sms.module_id = m.module_id
      LEFT JOIN student_software_selections sss ON sr.response_id = sss.response_id
      LEFT JOIN software sw ON sss.software_id = sw.software_id
    `;

    const params = [];
    if (option) {
      query += ' WHERE sr.selected_option = ?';
      params.push(option);
    }

    query += ' GROUP BY sr.response_id ORDER BY sr.submitted_at DESC';

    const [results] = await pool.execute(query, params);
    res.json({ success: true, data: results, count: results.length });
  } catch (error) {
    console.error('Detailed report error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// ============================================
// 8. ADMIN CONTROLLER - controllers/adminController.js
// ============================================
const pool = require('../config/database');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }

    const [users] = await pool.execute(
      'SELECT * FROM admin_users WHERE username = ? AND is_active = TRUE LIMIT 1',
      [username]
    );

    if (users.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const admin = users[0];
    const validPassword = await bcrypt.compare(password, admin.password_hash);

    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Update last login
    await pool.execute(
      'UPDATE admin_users SET last_login = NOW() WHERE admin_id = ?',
      [admin.admin_id]
    );

    const token = jwt.sign(
      { 
        admin_id: admin.admin_id, 
        username: admin.username, 
        role: admin.role 
      },
      process.env.JWT_SECRET || 'your_secret_key_change_in_production',
      { expiresIn: '24h' }
    );

    res.json({ 
      success: true, 
      token, 
      admin: { 
        admin_id: admin.admin_id, 
        username: admin.username, 
        role: admin.role,
        email: admin.email
      } 
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: error.message });
  }
};

exports.exportToCSV = async (req, res) => {
  try {
    const [data] = await pool.execute(`
      SELECT 
        s.email,
        s.index_number,
        s.year_of_study,
        s.phone_number,
        sr.selected_option,
        GROUP_CONCAT(DISTINCT m.module_name SEPARATOR '; ') as modules,
        GROUP_CONCAT(DISTINCT sw.software_name SEPARATOR '; ') as software,
        sr.additional_course_suggestion,
        sr.submitted_at
      FROM students s
      JOIN survey_responses sr ON s.student_id = sr.student_id
      LEFT JOIN student_module_selections sms ON sr.response_id = sms.response_id
      LEFT JOIN modules m ON sms.module_id = m.module_id
      LEFT JOIN student_software_selections sss ON sr.response_id = sss.response_id
      LEFT JOIN software sw ON sss.software_id = sw.software_id
      GROUP BY sr.response_id
      ORDER BY sr.submitted_at DESC
    `);

    const csv = convertToCSV(data);
    const filename = `mmesa_survey_${new Date().toISOString().split('T')[0]}.csv`;
    
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send('\uFEFF' + csv); // Add BOM for Excel UTF-8 compatibility
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: error.message });
  }
};

exports.getAdminStats = async (req, res) => {
  try {
    const [totalStudents] = await pool.execute('SELECT COUNT(*) as count FROM students');
    const [totalResponses] = await pool.execute('SELECT COUNT(*) as count FROM survey_responses');
    const [totalModuleSelections] = await pool.execute('SELECT COUNT(*) as count FROM student_module_selections');
    const [totalSoftwareSelections] = await pool.execute('SELECT COUNT(*) as count FROM student_software_selections');

    res.json({
      success: true,
      stats: {
        totalStudents: totalStudents[0].count,
        totalResponses: totalResponses[0].count,
        totalModuleSelections: totalModuleSelections[0].count,
        totalSoftwareSelections: totalSoftwareSelections[0].count
      }
    });
  } catch (error) {
    console.error('Admin stats error:', error);
    res.status(500).json({ error: error.message });
  }
};

const convertToCSV = (data) => {
  const headers = ['Email', 'Index Number', 'Year', 'Phone', 'Option', 'Modules', 'Software', 'Suggestion', 'Submitted At'];
  
  const rows = data.map(row => [
    row.email,
    row.index_number,
    row.year_of_study,
    row.phone_number,
    row.selected_option,
    row.modules || '',
    row.software || '',
    row.additional_course_suggestion || '',
    row.submitted_at
  ]);

  const escapedHeaders = headers.map(h => `"${h}"`).join(',');
  const escapedRows = rows.map(row => 
    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
  );

  return [escapedHeaders, ...escapedRows].join('\n');
};

// ============================================
// 9. STUDENT CONTROLLER - controllers/studentController.js
// ============================================
const pool = require('../config/database');
const Student = require('../models/Student');

exports.getAllStudents = async (req, res) => {
  try {
    const students = await Student.getAll();
    res.json({ success: true, data: students, count: students.length });
  } catch (error) {
    console.error('Get students error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getStudent = async (req, res) => {
  try {
    const { id } = req.params;
    const student = await Student.findById(id);

    if (!student) {
      return res.status(404).json({ success: false, error: 'Student not found' });
    }

    // Get student's responses
    const [responses] = await pool.execute(
      'SELECT * FROM survey_responses WHERE student_id = ? ORDER BY submitted_at DESC',
      [id]
    );

    res.json({ success: true, student, responses });
  } catch (error) {
    console.error('Get student error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getStudentByEmail = async (req, res) => {
  try {
    const { email } = req.params;
    const student = await Student.findByEmail(email);

    if (!student) {
      return res.status(404).json({ success: false, error: 'Student not found' });
    }

    res.json({ success: true, data: student });
  } catch (error) {
    console.error('Get student by email error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getStudentsByYear = async (req, res) => {
  try {
    const { year } = req.params;
    const students = await Student.getByYear(year);
    res.json({ success: true, data: students, count: students.length });
  } catch (error) {
    console.error('Get students by year error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

exports.getStudentStats = async (req, res) => {
  try {
    const [statsByYear] = await pool.execute(`
      SELECT 
        year_of_study,
        COUNT(*) as count
      FROM students
      GROUP BY year_of_study
    `);

    const [totalStudents] = await pool.execute('SELECT COUNT(*) as count FROM students');

    res.json({ 
      success: true, 
      totalStudents: totalStudents[0].count,
      statsByYear 
    });
  } catch (error) {
    console.error('Student stats error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// ============================================
// 10. SURVEY ROUTES - routes/surveys.js
// ============================================
const express = require('express');
const router = express.Router();
const surveyController = require('../controllers/surveyController');

// Public routes
router.post('/submit', surveyController.submitSurvey);
router.get('/results', surveyController.getAllResults);
router.get('/statistics', surveyController.getStatistics);
router.get('/report', surveyController.getDetailedReport);

module.exports = router;

// ============================================
// 11. ADMIN ROUTES - routes/admin.js
// ============================================
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const { authenticateToken, isAdmin } = require('../middleware/auth');

// Public routes
router.post('/login', adminController.login);

// Protected routes
router.get('/export', authenticateToken, isAdmin, adminController.exportToCSV);
router.get('/stats', authenticateToken, isAdmin, adminController.getAdminStats);

module.exports = router;

// ============================================
// 12. STUDENT ROUTES - routes/students.js
// ============================================
const express = require('express');
const router = express.Router();
const studentController = require('../controllers/studentController');
const { authenticateToken, isAdmin } = require('../middleware/auth');

// Admin routes (protected)
router.get('/', authenticateToken, isAdmin, studentController.getAllStudents);
router.get('/stats', authenticateToken, isAdmin, studentController.getStudentStats);
router.get('/year/:year', authenticateToken, isAdmin, studentController.getStudentsByYear);
router.get('/:id', authenticateToken, isAdmin, studentController.getStudent);
router.get('/email/:email', authenticateToken, isAdmin, studentController.getStudentByEmail);

module.exports = router;

// ============================================
// 13. AUTHENTICATION MIDDLEWARE - middleware/auth.js
// ============================================
const jwt = require('jsonwebtoken');

exports.authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'your_secret_key_change_in_production', (err, admin) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.admin = admin;
    next();
  });
};

exports.isAdmin = (req, res, next) => {
  if (!req.admin || req.admin.role !== 'admin') {
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
};

exports.isAdminOrViewer = (req, res, next) => {
  if (!req.admin || (req.admin.role !== 'admin' && req.admin.role !== 'viewer')) {
    return res.status(403).json({ error: 'Authorized access required' });
  }
  next();
};

// ============================================
// 14. PACKAGE.JSON - package.json
// ============================================
/*
{
  "name": "mmesa-survey-backend",
  "version": "1.0.0",
  "description": "MMESA Short Course Survey Backend API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "keywords": ["survey", "mmesa", "backend", "api"],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "mysql2": "^3.6.0",
    "dotenv": "^16.0.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.0.0"
  }
}
*/

// ============================================
// 15. ENVIRONMENT FILE - .env
// ============================================
/*
# Server Configuration
PORT=5000
NODE_ENV=development
FRONTEND_URL=http://localhost:3000

# Database Configuration
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=
DB_NAME=mmesa_survey

# JWT Configuration
JWT_SECRET=your_very_long_random_secret_key_change_in_production_12345678

# Email Configuration (Optional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASSWORD=your_app_password
*/

// ============================================
// 16. SEED DATA SCRIPT - scripts/seedData.js
// ============================================
const pool = require('../config/database');

const seedDatabase = async () => {
  try {
    console.log('Starting database seed...');

    // Insert admin user (password: admin123)
    const hashedPassword = await require('bcryptjs').hash('admin123', 10);
    await pool.execute(
      'INSERT IGNORE INTO admin_users (username, email, password_hash, role, is_active) VALUES (?, ?, ?, ?, ?)',
      ['admin', 'admin@mmesa.com', hashedPassword, 'admin', true]
    );
    console.log('✓ Admin user created');

    // Insert categories
    const categories = [
      'Category 1',
      'Category 2',
      'Category 3',
      'Category 4',
      'Category 5',
      'Category 6',
      'Category 7'
    ];

    for (const category of categories) {
      await pool.execute(
        'INSERT IGNORE INTO module_categories (category_name) VALUES (?)',
        [category]
      );
    }
    console.log('✓ Categories created');

    // Get category IDs
    const [cats] = await pool.execute('SELECT * FROM module_categories');
    const categoryMap = {};
    cats.forEach(cat => {
      categoryMap[cat.category_name] = cat.category_id;
    });

    // Insert modules for each category
    const moduleData = {
      'Category 1': {
        major: 'Drilling & Blasting Technology',
        sub: [
          'Rock Mechanics & Geology for Drilling & Blasting',
          'Drilling Technology & Equipment',
          'Explosives Science & Technology',
          'Blast Design & Engineering',
          'Blasting Operations & Safety Management',
          'Blast Monitoring, Analysis & Optimization',
          'Environmental Management & Specialized Applications'
        ]
      },
      'Category 2': {
        major: 'Mine Excavation & Materials Transportation',
        sub: [
          'Mine Production Systems & Planning',
          'Excavation Equipment & Operations',
          'Loading Systems & Material Handling',
          'Hauling & Transportation Systems',
          'Equipment Maintenance & Reliability',
          'Safety Management & Operational Controls',
          'Performance Monitoring & Continuous Improvement'
        ]
      },
      'Category 3': {
        major: 'Excel & Power BI',
        sub: [
          'Excel Basics & Data Entry Mastery',
          'Data Organisation & Basic Analysis',
          'PivotTables & Advanced Reporting',
          'Advanced Functions & Data Manipulation',
          'Power BI Basics & Data Connection',
          'Visualization & Report Design',
          'Advanced Analytics & AI Integration',
          'Advanced DAX & Data Modelling'
        ]
      },
      'Category 4': {
        major: 'Mine Planning & Design Technology',
        sub: [
          'Exploration Drillhole Data Interpretation & Block Modelling',
          'Strategic Mine Planning & Optimization',
          'Open Pit Mine & Waste Dump Design',
          'Surface Mine Production Scheduling',
          'Advanced Drill & Blast Design',
          'Underground Mine Design for Mine Planners',
          'Equipment Productivity & Haulage Modelling',
          '3D Discrete Event Simulation of Haulage Networks'
        ]
      },
      'Category 5': {
        major: 'Occupational Health, Safety & Environment',
        sub: [
          'Principles of Occupational Health & Safety',
          'Hazard Identification, Risk Assessment & Control',
          'Legal & Regulatory Compliance in OHSE',
          'Accident Investigation & Root Cause Analysis',
          'Fatigue Risk Management & Human Factors in OHSE',
          'Mine Rescue Operations & Emergency Response',
          'Workplace Safety & Emergency Preparedness',
          'Environmental Management Systems & ISO 14001',
          'Industrial Hygiene & Toxicology',
          'Mine Environmental Protection & Sustainability',
          'Safety Audits & Inspections',
          'Construction Safety & Site Management'
        ]
      },
      'Category 6': {
        major: 'Data Science & Business Analytics',
        sub: [
          'Python Programming for Data Science',
          'Statistical Analysis & Hypothesis Testing',
          'Data Visualization & Business Intelligence',
          'Machine Learning & Predictive Analytics',
          'Big Data Analytics & AI Implementation',
          'Data Strategy & Organizational Transformation',
          'Capstone Project & Professional Portfolio'
        ]
      },
      'Category 7': {
        major: 'Creative Media and Digital Design',
        sub: [
          'Visual Design Foundations & Digital Image',
          'Vector Graphics & Brand Design Systems',
          'Professional Video Editing & Content Creation',
          '3D Modelling & Animation Fundamentals',
          'Advanced 3D & Cinema Production',
          'UI/UX & Interactive Media',
          '2D Animation & Motion Graphics',
          'Audio Production & Podcast Creation'
        ]
      }
    };

    for (const [catName, modules] of Object.entries(moduleData)) {
      const categoryId = categoryMap[catName];
      
      // Insert major module
      await pool.execute(
        'INSERT IGNORE INTO modules (category_id, module_name, is_major_module) VALUES (?, ?, ?)',
        [categoryId, modules.major, true]
      );

      // Insert sub-modules
      for (const subModule of modules.sub) {
        await pool.execute(
          'INSERT IGNORE INTO modules (category_id, module_name, is_major_module) VALUES (?, ?, ?)',
          [categoryId, subModule, false]
        );
      }
    }
    console.log('✓ Modules created');

    // Insert software
    const softwareList = [
      'Ball Mill Simulation Software',
      'Datamine',
      'Deswik',
      'Leapfrog',
      'Surpac',
      'ArcGIS',
      'Matlab',
      'Ansys',
      'Solidworks',
      'Autocad'
    ];

    for (const software of softwareList) {
      await pool.execute(
        'INSERT IGNORE INTO software (software_name) VALUES (?)',
        [software]
      );
    }
    console.log('✓ Software created');

    console.log('✓ Database seed completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Seed error:', error);
    process.exit(1);
  }
};

// Run if called directly
if (require.main === module) {
  seedDatabase();
}

module.exports = seedDatabase;

// ============================================
// 17. UTILITY FUNCTIONS - utils/validators.js
// ============================================
exports.validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

exports.validatePhone = (phone) => {
  const phoneRegex = /^[\d\s\-\+\(\)]{10,}$/;
  return phoneRegex.test(phone);
};

exports.validateIndexNumber = (indexNumber) => {
  return indexNumber && indexNumber.trim().length > 0;
};

exports.validateYear = (year) => {
  const validYears = ['Year 2', 'Year 3', 'Year 4'];
  return validYears.includes(year);
};

exports.validateOption = (option) => {
  const validOptions = ['Option 1', 'Option 2', 'Option 3'];
  return validOptions.includes(option);
};

// ============================================
// 18. LOGGER MIDDLEWARE - middleware/logger.js
// ============================================
exports.requestLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(
      `${new Date().toISOString()} - ${req.method} ${req.originalUrl} - ${res.statusCode} - ${duration}ms`
    );
  });
  
  next();
};

// ============================================
// 19. DEPLOYMENT GUIDE - DEPLOYMENT.md
// ============================================
/*
# MMESA Survey Backend Deployment Guide

## Prerequisites
- Node.js 14+
- MySQL 5.7+
- npm or yarn

## Local Development Setup

### 1. Install Dependencies
cd backend
npm install

### 2. Database Setup
mysql -u root -p < database/schema.sql
node scripts/seedData.js

### 3. Environment Variables
cp .env.example .env
Edit .env with your database credentials

### 4. Start Development Server
npm run dev

## Production Deployment

### Option 1: AWS EC2
1. Create EC2 instance (Ubuntu 20.04)
2. Install Node.js: curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash - && sudo apt-get install -y nodejs
3. Install MySQL: sudo apt-get install mysql-server
4. Clone repository and install dependencies
5. Setup environment variables
6. Use PM2: npm install -g pm2 && pm2 start server.js
7. Setup Nginx reverse proxy
8. Configure SSL with Let's Encrypt

### Option 2: Heroku
1. Create app: heroku create mmesa-survey-api
2. Add MySQL: heroku addons:create cleardb:ignite
3. Deploy: git push heroku main
4. Run migrations: heroku run node scripts/seedData.js

### Option 3: DigitalOcean App Platform
1. Connect GitHub repository
2. Set environment variables
3. Deploy via dashboard

## Security Checklist
- [ ] Change JWT_SECRET in production
- [ ] Set NODE_ENV=production
- [ ] Enable HTTPS only
- [ ] Setup rate limiting
- [ ] Configure CORS properly
- [ ] Regular database backups
- [ ] Monitor error logs
- [ ] Setup alerting

## API Documentation

### Survey Endpoints
POST /api/surveys/submit - Submit survey
GET /api/surveys/results - Get all results
GET /api/surveys/statistics - Get statistics

### Admin Endpoints
POST /api/admin/login - Admin login
GET /api/admin/export - Export to CSV
GET /api/admin/stats - Admin statistics

### Student Endpoints
GET /api/students - Get all students
GET /api/students/:id - Get student by ID
GET /api/students/email/:email - Get student by email
*/

// ============================================
// 20. CONFIGURATION - config/constants.js
// ============================================
 

// ============================================
// 21. ERROR HANDLER - middleware/errorHandler.js
// ============================================
exports.handleError = (err, req, res, next) => {
  console.error('Error:', err);

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      error: 'Validation error',
      details: err.message
    });
  }

  if (err.name === 'AuthenticationError') {
    return res.status(401).json({
      success: false,
      error: 'Authentication failed'
    });
  }

  if (err.code === 'ER_DUP_ENTRY') {
    return res.status(400).json({
      success: false,
      error: 'Duplicate entry'
    });
  }

  res.status(500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' ? 'Internal server error' : err.message
  });
};

// ============================================
// 22. PROJECT STRUCTURE SUMMARY
// ============================================
/*
backend/
├── server.js                          # Main server file
├── package.json                        # Dependencies
├── .env                               # Environment variables
├── .gitignore
│
├── config/
│   ├── database.js                    # MySQL connection pool
│   └── constants.js                   # App constants
│
├── models/
│   ├── Student.js                     # Student model
│   ├── SurveyResponse.js             # Survey response model
│   ├── Module.js                      # Module model
│   └── Software.js                    # Software model
│
├── controllers/
│   ├── surveyController.js            # Survey logic
│   ├── adminController.js             # Admin logic
│   └── studentController.js           # Student logic
│
├── routes/
│   ├── surveys.js                     # Survey routes
│   ├── admin.js                       # Admin routes
│   └── students.js                    # Student routes
│
├── middleware/
│   ├── auth.js                        # Authentication middleware
│   ├── errorHandler.js                # Error handling
│   └── logger.js                      # Request logging
│
├── utils/
│   └── validators.js                  # Validation functions
│
├── scripts/
│   └── seedData.js                    # Database seeding
│
└── database/
    └── schema.sql                     # Database schema
*/

// ============================================
// 23. TESTING SETUP - jest.config.js
// ============================================
/*
module.exports = {
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.test.js'],
  collectCoverageFrom: [
    'controllers/**/*.js',
    'models/**/*.js',
    'routes/**/*.js',
    '!node_modules/**'
  ],
  setupFiles: ['<rootDir>/__tests__/setup.js']
};
*/

// ============================================
// 24. QUICK START COMMANDS
// ============================================
/*
# Install dependencies
npm install

# Run database migrations
mysql -u root -p < database/schema.sql

# Seed database with initial data
node scripts/seedData.js

# Start development server with auto-reload
npm run dev

# Start production server
npm start

# Run tests
npm test

# View logs
tail -f logs/error.log

# Database backup
mysqldump -u root -p mmesa_survey > backup.sql

# Database restore
mysql -u root -p mmesa_survey < backup.sql
*/

module.exports = {};